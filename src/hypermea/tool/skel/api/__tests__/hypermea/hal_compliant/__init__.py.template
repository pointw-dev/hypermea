import json
import uritemplate
from pytest_bdd import given, when, then, parsers
from assertpy import assert_that
from __tests__ import *
FEATURE = 'hypermea/hal_compliant.feature'


def href_from_resource(resource, rel, template_values=None):
    url = resource.get('_links', {}).get(rel, {}).get('href')
    url = uritemplate.expand(url, template_values or {})
    return url

def validate_links(context, resource, datatable):
    for row in datatable[1:]:  # peel off header row
        rel, value, is_templated = row
        my_id = resource.get('_id', '')
        person_ref = resource.get('_people_ref', '')
        value = (value
                 .replace('[[first_person_id]]', context['first_person_id'])
                 .replace('[[first_car_id]]', context['first_car_id'])
                 .replace('[[my_id]]', my_id)
                 .replace('[[my_person_id]]', person_ref)
                 )
        link = resource.get('_links', {}).get(rel, {})
        assert_that(link.get('href')).is_equal_to(value)
        assert_that(link.get('templated', False)).is_equal_to(is_templated == 'true')


@given('the client has fetched the home resource')
def step_impl(api, context):
    response = api.get('/')
    context['home'] = response.json


@when(parsers.parse('a client fetches the {rel} resource collection'))
def step_impl(api, context, rel):
    context['rel'] = rel
    url = href_from_resource(context['home'], rel)
    response = api.get(url)
    context['resource'] = response.json

@when(parsers.parse('a client fetches a single {rel} resource'))
def step_impl(api, context, rel):
    context['rel'] = rel
    my_id = context['first_person_id'] if rel == 'people' else context['first_car_id']
    response = api.get(f'/{rel}/{my_id}')
    context['resource'] = response.json

@when('a client fetches the cars belonging to one of the people collection')
def step_impl(api, context):
    response = api.get(f'/people/{context["first_person_id"]}/cars')
    context['resource'] = response.json


@when(parsers.parse('a client adds a single {rel} resource'))
def step_impl(api, context, rel):
    person = {
        'name': rel
    }
    response = api.post(f'/{rel}/', data=json.dumps(person), content_type='application/json')
    context['resource'] = response.json

@when('a client adds to the cars belonging to one of the people collection')
def step_impl(api, context):
    car = {
        'name': 'a car'
    }
    response = api.post(f'/people/{context["first_person_id"]}/cars', data=json.dumps(car), content_type='application/json')
    context['resource'] = response.json


@then('its _links property includes')
def step_impl(context, datatable):
    validate_links(context, context['resource'], datatable)

@then('its _embedded property includes')
def step_impl(context, datatable):
    embedded = context['resource'].get('_embedded', {})
    for row in datatable[1:]:  # peel off header row
        rel, type, count = row
        assert_that(embedded.get(rel, None)).is_type_of(list if type == 'collection' else dict)
        if type == 'collection':
            assert_that(len(embedded.get(rel, []))).is_equal_to(int(count))

@then('the resource has no embedded property')
def step_impl(context):
    assert_that(context['resource'].get('_embedded', None)).is_none()


@then(parsers.parse('each _embedded {rel} has a _links property with'))
def step_impl(context, rel, datatable):
    embedded = context['resource'].get('_embedded', {}).get(rel, {})
    if isinstance(embedded, dict):
        validate_links(context, embedded, datatable)
    else:
        for item in embedded:
            validate_links(context, item, datatable)


